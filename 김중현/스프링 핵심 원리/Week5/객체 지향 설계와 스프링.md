## Section 1. 객체 지향 설계와 스프링
### 스프링이란?
#### Spring
- **필수: 스프링 프레임워크, 스프링 부트**
- 선택: 스프링 데이터, 스프링 섹션, 스프링 시큐리티, 스프링 Rest Docs, 스프링 배치, 스프링 클라우드
<br>

#### 스프링 프레임워크
- **핵심 기술: 스프링 DI 컨테이너, AOP, 이벤트**
- 웹 기술: 스프링 MVC, 스프링 WebFlux
- 데이터 접근 기술: 트랜잭션, JDBC, ORM 지원, XML 지원
- 기술 통합: 캐시, 이메일, 원격 접근, 스케줄링
- 테스트: 스프링 기반 테스트 지원
- 언어: 코틀린, 그루비
<br>

#### 스프링 부트
- 스프링을 편리하게 사용할 수 있도록 지원하는 역할
- 단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성
- 웹 서버(Tomcat)를 내장해 별도의 웹 서버 설치할 필요 X
- 손 쉬운 빌드 구성을 위한 starter 종속성 제공
- 스프링과 서드파티(외부) 라이브러리 자동 구성 (궁합이 잘 맞는 외부 라이브러리 및 버전까지 자동으로 구성)
- 메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공
- 관례를 따른 간결한 설정 <br>
→ 스프링 부트는 스프링 프레임워크와 별도로 사용할 수 있는 것이 아니다. 스프링 프레임워크나 다른 여러가지 것들을 편리하게 사용할 수 있게 도와주는 <br>
  껍데기 역할을 하는 것이다.
<br>

#### 스프링 단어
1. 스프링 DI 컨테이너 기술
2. 스프링 프레임워크
3. 스프링 부트, 스프링 프레임워크 등을 모두 포함한 스프링 생태계
<br>

#### 스프링의 핵심
- 스프링은 자바 언어 기반의 프레임워크
- 자바의 가장 큰 특징 = 객체 지향
- 스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크 <br>
→ 스프링은 **좋은 객체 지향 애플리케이션**을 개발할 수 있게 도와주는 프레임워크 <br>
**→ 그렇다면 좋은 객체 지향 프로그램이란 뭘까?**
<br>
<br>
<br>

### 좋은 객체 지향 프로그래밍이란?
#### 객체 지향 프로그래밍
- 프로그램을 여러 개의 독립 단위, 즉 객체들의 모임으로 파악
  - 각 객체는 메세지를 주고받고, 데이터를 처리
- 프로그램을 **유연하고 변경이 용이**하게 만든다.
  - 컴포넌트를 쉽고 유연하게 변경하고 갈아 끼우면서 개발
- **객체 지향의 핵심 = 다형성 (Polymorphism)**
<br>

#### 역할과 구현을 분리 - 자바 언어
- 자바의 다형성을 활용
  - 역할 = 인터페이스
  - 구현 = 인터페이스를 구현한 클래스, 구현 객체
- 역할과 구현을 명확히 분리해 객체를 설계, 객체 설계 시 역할(인터페이스)을 먼저 부여하고, 그 역할을 수행하는 구현 객체를 만든다.
<br>

- 스프링 입문 프로젝트에서의 다형성
<img width="998" alt="스크린샷 2022-05-11 오후 1 19 48" src="https://user-images.githubusercontent.com/80838501/167768450-99148773-4abf-4299-8098-46708e48919a.png">

```java
public class MemberService {
    private MemberRepository memberRepository = new MemoryMemberRepository();
}
```
```java
public class MemberService {
 // private MemberRepository = new MemoryMemberRepository();
    private MemberRepository = new JdbcMemberRepository();
}
```
<br>

#### 다형성의 본질
- 인터페이스를 구현한 객체 인스턴스를 **실행 시점에 유연하게 변경**할 수 있다.
- **협력**이라는 객체 사이의 관계에서부터 다형성의 본질을 이해해야 한다.
- **클라이언트를 변경하지 않고 서버의 구현 기능을 유연하게 변경하는 것**이 다형성의 본질이다.
<br>

#### 역할(인터페이스)과 구현을 분리하는 것의 한계점
- 역할(인터페이스) 자체가 변경되면, 클라이언트와 서버 모두에 큰 변경이 발생 <br>
**→ 인터페이스를 안정적으로 잘 설계하는 것이 매우 중요**
<br>

#### 스프링과 객체 지향
- **다형성**이 가장 중요
- 스프링은 다형성을 극대화해 이용할 수 있게 도와주는 역할
- 스프링에서의 `IoC`, `DI`는 다형성을 활용해 역할과 구현을 편리하게 다룰 수 있도록 지원하는 역할
- 스프링을 사용하면 구현을 편리하게 변경할 수 있다.
<br>
<br>
<br>

### 좋은 객체 지향 설계의 5가지 원칙 - SOLID
#### SOLID: 좋은 객체 지향 설계의 5가지 원칙
```
SRP: 단일 책임 원칙 (Single Responsibility Principle)
OCP: 개방-폐쇄 원칙 (Open/Closed Principle)
LSP: 리스코프 치환 원칙 (Liskov Substitution Principle)
ISP: 인터페이스 분리 원칙 (Interface Segregation Principle)
DIP: 의존관계 역전 원칙 (Dependency Inversion Principle)
```

#### SRP: 단일 책임 원칙
- 한 클래스는 하나의 책임만 가진다.
- 중요한 판단 기준은 **변경**. 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙(SRP)를 잘 따른 것.
<br>

#### OCP: 개방-폐쇄 원칙
- 소프트웨어 요소는 **확장에는 열려 있으나 변경에는 닫혀** 있어야 한다. <br>
→ 다형성을 활용!
- 인터페이스를 구현한 새로운 클래스를 만들어 새로운 기능을 구현 (확장에는 열려있고, 변경에는 닫혀 있게)

**문제점**
- 위의 스프링 입문 프로젝트 예시에서 MemberService 클라이언트가 구현 클래스를 직접 선택
```java
private MemberRepository = new MemoryMemberRepository(); //기존 코드
private MemberRepository = new JdbcMemberRepository(); //변경 코드
```
→ 구현 객체를 변경하기 위해서는 클라이언트 코드를 변경해야 한다. 즉, 다형성을 사용했지만 OCP 원칙을 지킬 수 없다. (코드 변경이 발생) <br>
**→ 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요!** (스프링 컨테이너, DI, IoC 컨테이너)
<br>
<br>

#### LSP: 리스코프 치환 원칙
- 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
- 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다. (다형성을 지원하기 위한 원칙)
- Ex) 자동차 인터페이스의 엑셀 기능은 앞으로 가는 기능이기 때문에, 하위 클래스에서 엑셀을 뒤로 가게 구현하면 LSP 위반한 것
<br>

#### ISP: 인터페이스 분리 원칙
- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다
- Ex) 자동차 인터페이스 하나를 `운전 인터페이스`와 `정비 인터페이스`로 분리 <br>
     → 사용자 클라이언트를 `운전자 클라이언트`와 `정비사 클라이언트`로 분리 가능 <br>
     분리하면 정비 인터페이스가 변해도 운전자 클라이언트에 영향을 주지 않고, 인퍼테이스가 명확해지며 대체 가능성이 높아진다.
<br>

#### DIP: 의존관계 역전 원칙
- "프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다." 의존성 주입은 이 원칙을 따르는 방법 중 하나다.
- 구현 클래스에 의존하지 말고, 인터페이스에 의존해야 한다. 즉, **역할에 의존**해야하며, 구현에 의존하면 안된다. 
- 위의 스프링 입문 프로젝트 예시에서 MemberService는 인터페이스(MemberRepository)에 의존하지만, 동시에 구현 클래스(MemoryMemberRepository)에 의존한다. 
```java
MemberRepository m = new MemoryMemberRepository();
```
→ 즉, MemberService 클라이언트가 구현 클래스를 직접 선택(의존)하므로, **DIP 위반**
<br>
<br>

#### 정리
- 객체 지향의 핵심 = 다형성
- 다형성만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경될 수 밖에 없다. **즉, 다형성만으로는 OCP, DIP를 지킬 수 없다.** <br>
→ 뭔가 더 필요하다!
